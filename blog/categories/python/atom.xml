<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | 研究中心]]></title>
  <link href="http://zhangchuan.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://zhangchuan.github.com/"/>
  <updated>2012-02-24T19:04:25+08:00</updated>
  <id>http://zhangchuan.github.com/</id>
  <author>
    <name><![CDATA[Cloud.Zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PyMongo 创建,更新删除文档[MongoDB权威指南 第三章]]]></title>
    <link href="http://zhangchuan.github.com/blog/2012/02/23/120934-python/"/>
    <updated>2012-02-23T12:09:00+08:00</updated>
    <id>http://zhangchuan.github.com/blog/2012/02/23/120934-python</id>
    <content type="html"><![CDATA[<ul>
<li>#

<pre><code>from pymongo import Connection
connection = Connection()
db = connection['test']
collection = db['col_test']
</code></pre></li>
<li><p>3.1 插入并保存文档</p>

<pre><code>mongo&gt; db.foo.insert({"bar": "baz"})
#
db.foo.insert[{"bar": "baz"}]
</code></pre></li>
<li><p>3.1.1 批量插入</p></li>
<li>批量插入是单个TCP请求, 提高处理效率. 只适用将多个文档插入到一个集合.</li>
<li><p>批量插入有消息长度为16M的限制.</p>

<pre><code>mongo&gt; ???
# 批量插入对象必须是序列对象 
db.foo.insert([{"bar": "baz"}, {"baz": "bar"}])
</code></pre></li>
<li><p>3.1.2 插入: 原理和作用</p></li>
<li>在启动时打开--objecheck选项会检查输入的有效性, 但会影响效率</li>
<li><p>文档不能超过4M</p></li>
<li><p>3.2 删除文档</p>

<pre><code># 删除集合中所有文档. 但不会删除集合本身及其索引.
mongo&gt; db.foo.remove()
# 也可按指定条件删除
db.foo.remove()
db.foo.remove({"bar": "baz"})
</code></pre></li>
<li><p>删除速度</p></li>
<li>删除集合比删除文档速度更快.

<pre><code>import time
from pymongo import Connection

db = Connection().foo
collection = db.bar
# 插入测试记录
for i in range(1000000):
    collection.insert({"foo": "bar", "baz": i, "z": 10 - i})

start = time.time()
# 使用db.drop_collection("bar")代替下面两行, 速度提升会相当明显
#db.drop_collection("bar")
collection.remove()
collection.find_one()

total = time.time() - start
print "%d seconds" % total
</code></pre></li>
<li>3.3 更新文档</li>
<li>update有2个参数, 一个是查询文档, 一个是修改文档</li>
<li>3.3.1 文档替换</li>
<li>确保更新总是指向唯一文档

<pre><code>from pymongo import Connection
db = Connection().foo
# 导入测试数据
db.users.insert({"name": "joe", "friends": 32, "enemies": 2})
# mongo shell 
mongo&gt; var joe = db.users.findOne({"name": "joe"});
mongo&gt; joe.relationships = {"friends": joe.friends, "enemies": joe.enemies};
mongo&gt; joe.username = joe.name;
mongo&gt; delete joe.friends;
mongo&gt; delete joe.enemies;
mongo&gt; delete joe.name;
mongo&gt; db.users.update({"name": "joe"}, joe);
# OK 转换为python代码
joe = db.users.find_one({"name": "joe"})
joe['relationships'] = {"friends": joe['friends'], "enemies": joe['enemies']}
joe['username'] = joe['name']
del joe['friends']
del joe['enemies']
del joe['name']
# 不是子字典?
db.users.update({"username": joe['username']}, joe)
</code></pre></li>
<li>3.3.2 使用修改器

<pre><code># 每当有人访问页面的时候, 增加计数器
from pymongo import Connection
db = Connection().foo
# 导入测试数据
db.analytics.insert({"url":"www.example.com", "pageviews": 52})
# 使用$inc修改器
db.analytics.update({"url":"www.example.com"}, {"$inc": {"pageviews": 1}})
# 执行db.analytics.find()会发现"pageviews"的值增加了1
db.analytics.find().next()
</code></pre></li>
<li>1 "$set"修改器入门</li>
<li>"$set"用来指定一个键的数值,如果不存在就创建它

<pre><code># 导入测试数据
db.users.insert({"name": "joe", "age": 30, "sex": "male", "location": "Wisconsin"})
# 添加喜欢的书籍
db.users.update({"name": "joe", "age": 30}, {"$set": {"favorite book": "war and peace"}})
# 修改喜欢的书籍
db.users.update({"name": "joe", "age": 30}, {"$set": {"favorite book": "green eggs and ham"}})
# cool的是还可以修改键值的数据类型
db.users.update({"name": "joe", "age": 30}, {"$set": {"favorite book": ["cat's cradle", "foundation trilogy", "ender's game"]}}) 
# 不爱读书了, 可以试试"$unset"
db.users.update({"name": "joe", "age": 30}, {"$unset": {"favorite book": 1}})

# 也可用"$set"修改内嵌的文档
# 导入测试数据 
from pymongo import Connection
db = Connection().blog
db.posts.insert({"title": "A Blog Post", "content": "...", "author": {"name": "joe", "email": "joe@example.com"}})
# OK, 开始更新
db.posts.update({"author.name": "joe"}, {"$set": {"author.name": "joe schmoe"}})
</code></pre></li>
<li>2 增加和减少</li>
<li>"$inc" 修改器用来增加已有的键值, 或在不存在的时候创建一个键, 操作对象必须是数字类型.

<pre><code>from pymongo import Connection
db = Connection().foo
db.games.insert({"game": "pinball", "user": "joe"})
# 分数并不存在, "$inc"创建这个键后, 设定初始值
db.games.update({"game": "pinball", "user": "joe"}, {"$inc": {"score": 50}})
# 如果小球落入加分区, 要加10000分
db.games.update({"game": "pinball", "user": "joe"}, {"$inc": {"score": 10000}})
</code></pre></li>
<li>3 数组操作器</li>
<li>"$push"向已有的数据末尾加入一个元素

<pre><code>from pymongo import Connection
db = Connection().blog
# 导入测试数据
db.posts.insert({"title": "A blog post", "content": "..."})
# 下面两行有待调试
db.posts.update({"title": "A blog post"}, {"$push": {"comments": {"name": "joe", "email": "joe@example.com", "content": "nice post."}}})
db.posts.update({"title": "A blog post"}, {"$push": {"comments": {"name": "bob", "email": "bob@example.com", "content": "good post."}}})
# "$ne", 如果一个值不在数据就把它加进去
db.papers.update({"authors cited": {"$ne": "Richie"}}, {"$push": {"authors cited": "Richie"}})
# 不过有时更适合用"$addToSet"
# 导入测试数据
db.users.insert({"username": "joe", "emails": ["joe@example.com", "joe@gmail.com", "joe@yahoo.com"]})
# 用"$addToSet"可以避免重复
db.users.update({"username": "joe"}, {"$addToSet": {"emails": "joe@gmail.com"}})
db.users.update({"username": "joe"}, {"$addToSet": {"emails": "joe@gmail.com"}})
# "$addToSet"和"$each"组合起来, 可以添加多个不同的值. "$ne"和"$push"就不能实现.
db.users.update({"username": "joe"}, {"$addToSet": {"emails": {"$each": ["joe@php.net", "joe@example.com", "joe@python.org"]}}})
# 从数组删除元素, 可以使用"$pop"修改器
# 从数组末尾删除一个元素
{$pop: {key: 1}}
# 从数组头部删除
{$pop: {key: -1}}
# 基于特定条件删除元素, 可以用"$pull"
db.lists.insert({"todo": ["dishes", "laundry", "dry cleaning"]})
db.lists.update({}, {"$pull": {"todo": "laundry"}})
</code></pre></li>
<li>4 数组的定位修改器

<pre><code># 若数组包含多个值, 针对某一特定值的修改需要使用定位操作符"$"定位操作,数组下标以0开始
# 导入测试数据
db.posts.insert({"content": "...", "comments": [{"comment": "good post", "author": "John", "votes":0},
{"comment": "i thought it was too short", "author": "Claire", "votes":3},
{"comment": "free watches", "author": "Alice", "votes":-1}]})
# 增加第一个评论的投票数量
db.posts.update({"content": "..."}, {"$inc": {"comments.0.votes": 1}})
# 但是有时怎么会预先知道下标呢? 比如上面的comments.0.votes. 这时就要用到"$"去更新,如果有多个匹配,只会更新第一个匹配元素
db.posts.update({"comments.author": "John"}, {"$set": {"comments.$.author": "Jim"}})
</code></pre></li>
<li>5 修改器的速度</li>
<li><p>在不改变文档大小的前提下,更新会很快. "$inc", "$set"相对更快."$push", "$pull"相对更慢</p>

<pre><code>from pymongo import Connection
import time

db = Connection().performance_test
db.drop_collection("updates")
collection = db.updates

collection.insert({"x": 1})
# make sure the insert is complete before we start timing
collection.find_one()

start = time.time()

for i in range(100000):
    collection.update({}, {"$inc": {"x": 1}})
    # 如果改用"$push"的话. 速度就很悲剧了
    collection.update({}, {"$push": {"x": 1}})

# make sure the updates are complete before we stop timing
collection.find_one()

print time.time() - start
</code></pre></li>
<li><p>3.3.3 upsert</p></li>
<li><p>upsert是一种特殊的更新. 如果文档不符合更新条件, 则会以这个条件和更新文档为基础创建一个新文档</p>

<pre><code># update 第3个参数表示这个是upsert. &lt;-true
db.analytics.update({"url": "/blog"}, {"$inc": {"visits": 1}}, True)
db.math.remove()
db.math.update({"count": 25}, {"$inc": {"count": 3}}, true)
db.math.find_one()
# 下面会再新建一个文档. 为什么, 因为上面的count已经是28, 由于没有匹配
db.math.update({"count": 25}, {"$inc": {"count": 3}}, true)
</code></pre></li>
<li><p>save是一个shell函数, 可以在文档不存在时插入(文档不含有_id), 存在时更新(含有_id), 调用upsert</p>

<pre><code>x = db.math.find_one()
x['count'] = 20
db.math.save(x)
</code></pre></li>
<li>3.3.4 更新多个文档</li>
<li>默认只更新第一个匹配的文档, 如要要让所有文档更新, 可以设置update的第4个参数为true

<pre><code># 给所有在特定日期过生的用户发一份礼物.
# help(db.users.update)
db.users.update({"birthday": "10/13/1978"}, {"$set": {"gift": "Happy Birtday!"}}, False, multi=True)
# 想要知道到底更新了多少条文档
db.count.update({x: 1}, {"$inc": {x: 1}}, False, multi=True)
mongo&gt; db.runCommand({getLastError: 1})
</code></pre></li>
<li>3.3.5 返回已更新的文档</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[monogodb 大杂烩]]></title>
    <link href="http://zhangchuan.github.com/blog/2012/02/22/141006-mongodb/"/>
    <updated>2012-02-22T14:10:00+08:00</updated>
    <id>http://zhangchuan.github.com/blog/2012/02/22/141006-mongodb</id>
    <content type="html"><![CDATA[<h1>一, 安装</h1>

<p><a href="http://www.mongodb.org/downloads">下载连接</a></p>

<pre><code># mkdir -p /usr/local/mongo/{etc,bin,log}
# mkdir -p /data

# /usr/local/mongo/etc/mongodb.conf
# 数据文件存放路径
dbpath=/var/lib/mongodb

# 错误日志文件
logpath=/var/log/mongodb/mongodb.log

# 错误日志文件采用追加模式,默认是覆盖模式
logappend=true

# 对外服务绑定IP. 根据业务需要, 尽量不要放公网.
#bind_ip

# 对外服务绑定端口,Web管理端口在这个port的基础上+1000 
port = 27017
# 开启简单的rest API, 提供Web管理界面操作支持
rest = true

# 定期显示CPU的CPU利用率和iowait
#cpu = true

# 关闭验证(默认)
#noauth = true
# 启用验证
#auth = true

# 详细输出
#verbose = true
# 安静输出
#quiet = true

# 在收到客户数据,检查数据的有效性
#objcheck = true

# 限制每个数据库的文件数，设置默认为8
#quota = true
# Set oplogging level where n is
#   0=off (default)
#   1=W
#   2=R
#   3=both
#   7=W+some reads
# 规定每个数据库允许的文件数
#quotaFiles

# diaglog选项 0=off 1=W 2=R 3=both 7=W+some reads
# 提供的方式，是只读，只写，还是读写都行，还是主要写+部分的读模式
#diaglog = 0

# 调试诊断选项
#nocursors = true
# 忽略查询命中率
#nohints = true
# 关闭http接口访问
#nohttpinterface = true
# 禁用脚本引擎
#noscripting = true
# 不允许表扫描
#notablescan = true
# 禁用数据文件预分配(往往影响性能)
#noprealloc = true
# 设置信数据库.ns文件大小(MB) =16
#nssize = &lt;size&gt;

#修复所有数据库
#repair
#修复库生成的文件的目录,默认为目录名称dbpath
#repairpath
#数据写入磁盘的时间秒数(0=never,不推荐),默认60
#syncdelay

# Accout token for Mongo monitoring server.
#mms-token = &lt;token&gt;
# Server name for Mongo monitoring server.
#mms-name = &lt;server-name&gt;
# Ping interval for Mongo monitoring server.
#mms-interval = &lt;seconds&gt;

# 从一个dbpath里启用从库复制服务，该dbpath的数据库是主库的快照，可用于快速启用同步
#fastsync
# 如果从库与主库同步数据差得多，自动重新同步
#autoresync
# pair???
#pairwith
# 仲裁服务器，在主从和pair中用到
#arbiter
# 设置操作日志的大小(MB)
#oplogSize
# 设置存储操作日志的内存大小
#opIdMem

# 从库模式
#slave = true
# 当为从时，指定主的地址和端口
#source = master.example.com
# 设置从库同步主库的延迟时间
#slavedelay
# 指定单一的数据库复制
#only = master.example.com
# 主库模式
#master = true
#source = slave.example.com
# 设置副本集名称
# replSet = setname

# 声明这是一个集群的config服务,默认端口27019，默认目录/data/configdb
#configsvr
# 声明这是一个集群的分片,默认端口27018
#shardsvr
# 关闭偏执为moveChunk数据保存
#noMoveParanoia

# tree /usr/local/mongo/bin
|-- bsondump
|-- mongo
|-- mongod
|-- mongodump
|-- mongoexport
|-- mongofiles
|-- mongoimport
|-- mongorestore
|-- mongos
|-- mongosniff
|-- mongostat
|-- mongotopmongosniff

# mongostat --help
Fields
inserts      - # of inserts per second
query        - # of queries per second
update       - # of updates per second
delete       - # of deletes per second
getmore      - # of get mores (cursor batch) per second
command      - # of commands per second
flushes      - # of fsync flushes per second
mapped       - amount of data mmaped (total data size) megabytes
visze        - virtual size of process in megabytes
res          - resident size of process in megabytes
faults       - # of pages faults per sec (linux only)
locked       - percent of time in global write lock
idx miss     - percent of btree page misses (sampled)
qr|qw        - queue lengths for clients waiting (read|write)
ar|aw        - active clients (read|write)
netIn        - network traffic in - bits
netOut       - network traffic out - bits
conn         - number of open connections

# Python API
#easy_install pymongo
# -- python code --
from pymongo import Connection

# Making a Connection
#connection = Connection() #default host and port
connection = Connection('localhost', 27017)

# Getting a Database
#db = connection.test_database
db = connection['test-database']

# Getting a Collection
#collection = db.test_collection
collection = db['test-collection']

# Documents
import datetime

post = {"author": "Mike",
"text": "My first blog post!",
"tags": ["mongodb", "python", "pymongo"],
"date": datetime.datetime.utcnow()}

# Inserting a Document
posts = db.posts
posts.insert(post)
db.collection_names()

# Getting a Single Document With find_one()
print posts.find_one()
print posts.find_one({"author": "Mike"})
print posts.find_one({"author": "Eliot"})

# Bulk Inserts
new_posts = [{"author": "Mike",
    "text": "Another post!",
    "tags": ["bulk", "insert"],
    "date": datetime.datetime(2009, 11, 12, 11, 14)},
    {"author": "Eliot",
    "title": "MongoDB is fun",
    "text": "and pretty easy too!",
    "date": datetime.datetime(2009, 11, 10, 10, 45)}]
posts.insert(new_posts)

# Querying for More Than One Document
for post in posts.find():
    print post

for post in posts.find({"author": "Mike"}):
    print post

# Counting
posts.count()
posts.find({"author": "Mike"}).count()

# Range Queries
d = datetime.datetime(2009, 11, 12, 12)
for post in posts.find({"date": {"$lt": d}}).sort("author"):
    print post

# Indexing
posts.find({"date": {"$lt": d}}).sort("author").explain()["cursor"]
posts.find({"date": {"$lt": d}}).sort("author").explain()["nscanned"]

from pymongo import ASCENDING, DESCENDING
posts.create_index([("date", DESCENDING), ("author", ASCENDING)])
posts.find({"date": {"$lt": d}}).sort("author").explain()["cursor"]
posts.find({"date": {"$lt": d}}).sort("author").explain()["nscanned"]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[scribe安装]]></title>
    <link href="http://zhangchuan.github.com/blog/2012/02/15/143830-scribe/"/>
    <updated>2012-02-15T14:38:00+08:00</updated>
    <id>http://zhangchuan.github.com/blog/2012/02/15/143830-scribe</id>
    <content type="html"><![CDATA[<ul>
<li>ubuntu安装依赖libboost-all-dev, python-dev</li>
<li>centos安装依赖boost-devel, python-devel</li>
<li><p>boost库文件必须高于1.36版本, centos通常自带的boost版本较低,需编译安装.</p></li>
<li><p>编译thrift,不提供php与ruby支持.</p>

<pre><code>./configure --without-php_extension --without-php --without-ruby
make &amp;&amp; make install
cd lib/py
python setup.py install
cd ../../contrib/fb303/
./bootstrap.sh
make &amp;&amp; make install
cd py
python setup.py install

# 编译scribe
./bootstrap.sh 
make &amp;&amp; make install
mkdir /etc/scribe
cp -av examples/* /etc/scribe/
cd lib/py
python setup.py install
</code></pre></li>
</ul>


<h1>参考资料:</h1>

<p>http://agiletesting.blogspot.com/2009/10/compiling-installing-and-test-running.html
http://silas.sewell.org/blog/2009/05/12/pipe-apache-or-any-logs-to-scribe/</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Tips]]></title>
    <link href="http://zhangchuan.github.com/blog/2012/02/10/163323-python/"/>
    <updated>2012-02-10T16:33:00+08:00</updated>
    <id>http://zhangchuan.github.com/blog/2012/02/10/163323-python</id>
    <content type="html"><![CDATA[<h1>读取管道内容</h1>

<h1>print sys.stdin.read()</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python 参考手册 第21章]]></title>
    <link href="http://zhangchuan.github.com/blog/2012/01/19/095304-python/"/>
    <updated>2012-01-19T09:53:00+08:00</updated>
    <id>http://zhangchuan.github.com/blog/2012/01/19/095304-python</id>
    <content type="html"><![CDATA[<h1>第21章 网络编程和套接字</h1>

<ul>
<li><a href="#21.1">21.1 网络编程基础</a></li>
<li><a href="#21.2">21.2 asynchat模块</a></li>
</ul>


<h1 id=21.1>21.1 网络编程基础</h1>


<ul>
<li>python网络编程模块支持TCP和UDP两种Internet协议。</li>
<li>TCP协议是面向连接的可靠协议。</li>
<li>UDP是以数据包为基础的协议。</li>
<li>套接字类似文件的对象，使程序能够接受传入连接，进行传出连接，发送和接受数据。</li>
<li>接受连接的机器(服务器)必须将套接字绑定到已知端口，提供服务。(0-1023是保留端口)</li>
<li>使用socket模块编写TCP协议。

<pre><code># 时间服务器程序
from socket import *
import time

s = socket(AF_INET, SOCK_STREAM)  # 创建TCP套接字
s.bind(('', 8888))                # 绑定到端口8888
s.listen(5)                       # 监听，但只能挂起5个以下的连接

While True:
    client,addr = s.accept()      # 连接
    print("Got a connection from %s" % str(addr))
    timestr = time.ctime(time.time()) + "\r\n"
    client.send(timestr.encode('ascii'))
    client.close()

# 客户端程序:
from socket import *
s = socket(AF_INET, SOCK_STREAM)  # 创建TCP套接字
s.connect(('localhost', 8888)     # 连接到服务器
tm = s.recv(1024)                 # 最多接收1024个字节
s.close()
print("The time is %s" % tm.decode('ascii'))
</code></pre></li>
<li>网络协议经常以文本方式传输数据，要进行编码，解码处理。python3 默认使用Unicode编码。</li>
</ul>


<h1 id=21.2>21.2 asynchat 模块</h1>


<ul>
<li>简化了异步网络应用程序的实现过程。包装了asyncore的低级I/O功能和一个高级编程接口。</li>
<li>使用该模块，必须定义继承自async_chat的类。并定义两个方法：collect_incoming_data()和found_terminator()。</li>
<li>asynchat模块总是和asyncore模块一起使用。

<pre><code># 使用asynchat的异步HTTP服务器
import asynchat, asyncore, socket
import os
import mimetypes
try:
    from http.client import responses     # python3
except ImportError:
    from httplib import responses         # python2
# 该类插入到asyncore模块，仅处理接受的事件
class async_http(asyncore.dispatcher):
    def __init__(self, port):
        asyncore.dispatcher.__init__(self)
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.bind(('', port))
        self.listen(5)
    def handle_accept(self):
        client.addr = self.accept()
        return async_http_handler(client)

# 处理异步HTTP请求的类
class async_http_handler(asynchat.async_chat):
    def __init__(self, conn=None):
        asynchat.asycn_chat_.__init__(self.conn)
        self.data = []
        self.got_header = False
        self.set_terminator(b"\r\n\r\n")

    # 获取传入数据并添加到数据缓冲区
    def collect_incoming_data(self, data):
        if not self.got_header:
            self.data.append(data)

    # 到达终止符(空白行)
    def found_terminator(self):
        self.got_header = True
        header_data = b"".join(self.data)
        # 将报头数据(二进制)解码为文本以便进一步处理
        header_text = header_data.decode('latin-1')
        header_lines = header_text.splitlines()
        request = header_lines[0].split()
        op = request[0]
        url = request[1][1:]
        self.process_request(op, url)

    # 将文本加入到传出流，但首先要解码
    def push_text(self, text):
        self.push(text.encode('latin-1'))

    # 处理请求
    def process_request(self, op, url):
        if op == "GET":
            if not os.path.exists(url):
                self.send_error(404, "File %s not found\r\n")
            else:
                type, encoding = mimetypes.guess_type(url)
                size = os.path.getsize(url)
                self.path_text("HTTP/1.0 200 OK\r\n")
                self.push_text("Content-length: %s\r\n" % size) 
                self.push_text("Content-type: %s\r\n" % type)
                self.push_text("\r\n")
                self.push_with_producer(file_producer(url))
        else:
            self.send_error(501, "%s method not implemented" % op)

    # 错误处理  
    def send_error(self, code, message):
        self.push_text("HTTP/1.0 %s %s\r\n" % (code, responses[code]))
        self.push_text("Content-type: text/plain\r\n")
        self.push_text("\r\n")
        self.push_text(message)

class file_producer(object):
    def __init__(self, filename, buffer_size=512):
        self.f = open(filename, "rb")
        self.buffer_size = buffer_size
    def more(self):
        data = self.f.read(self.buffer_size)
        if not data:
            self.f.close()
        return data
a = async_http(8080)
asyncore.loop()
# 要测试该实例，需要提供一个URL，并且该URL必须对应运行服务器那个目录中的文件。
</code></pre></li>
</ul>

]]></content>
  </entry>
  
</feed>
