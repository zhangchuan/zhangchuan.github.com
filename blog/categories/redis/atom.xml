<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Redis | 研究中心]]></title>
  <link href="http://zhangchuan.github.com/blog/categories/redis/atom.xml" rel="self"/>
  <link href="http://zhangchuan.github.com/"/>
  <updated>2012-02-29T17:14:16+08:00</updated>
  <id>http://zhangchuan.github.com/</id>
  <author>
    <name><![CDATA[Cloud.Zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[python hiredis模块]]></title>
    <link href="http://zhangchuan.github.com/blog/2012/01/18/175036-python/"/>
    <updated>2012-01-18T17:50:00+08:00</updated>
    <id>http://zhangchuan.github.com/blog/2012/01/18/175036-python</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/pietern/hiredis-py">官方手册</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis的七种武器及其适合的应用场景]]></title>
    <link href="http://zhangchuan.github.com/blog/2012/01/15/155751-redis/"/>
    <updated>2012-01-15T15:57:00+08:00</updated>
    <id>http://zhangchuan.github.com/blog/2012/01/15/155751-redis</id>
    <content type="html"><![CDATA[<ul>
<li><p>2012年01月11日 00:05 来源：nosqlfan 作者：NoSQLfan 编辑：王玉圆</p></li>
<li><p><strong>【IT168 技术】长生剑、孔雀翎、碧玉刀、多情环、离别钩、霸王枪、拳头是古龙笔下的七种武器，而本文打算将Redis的几种使用方式 Strings、Hashs、Lists、Sets、Sorted Sets、Pub/Sub、Transactions 也比作七种武器，为大家讲解Redis的七种特性，并列举其适合的应用场景。</strong></p></li>
<li><strong>武器一：Strings</strong></li>
<li>Strings 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字。使用Strings类型，你可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作：</li>
<li>·获取字符串长度</li>
<li>·往字符串append内容</li>
<li>·设置和获取字符串的某一段内容</li>
<li>·设置及获取字符串的某一位(bit)</li>
<li><p>·批量设置一系列字符串的内容</p></li>
<li><p><strong>武器二：Hashs</strong></p></li>
<li><p>在Memcached中，我们经常将一些结构化的信息打包成hashmap，在客户端序列化后存储为一个字符串的值，比如用户的昵称、年龄、性别、积分等，这时候在需要修改其中某一项时，通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。这样不仅增大了开销，也不适用于一些可能并发操作的场合(比如两个并发的操作都需要修改积分)。而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。</p></li>
<li><p><strong>武器三：Lists</strong></p></li>
<li><p>Lists 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。</p></li>
<li><p><strong>武器四：Sets</strong></p></li>
<li><p>Sets 就是一个集合，集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p></li>
<li><p><strong>武器五：Sorted Sets</strong></p></li>
<li><p>和Sets相比，Sorted Sets增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的Sorted Sets，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p></li>
<li><p><strong>武器六：Pub/Sub</strong></p></li>
<li><p>Pub/Sub 从字面上理解就是发布(Publish)与订阅(Subscribe)，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p></li>
<li><p><strong>武器七：Transactions</strong></p></li>
<li>谁说NoSQL都不支持事务，虽然Redis的Transactions提供的并不是严格的ACID的事务(比如一串用EXEC提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行)，但是这个Transactions还是提供了基本的命令打包执行的功能(在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行)。Redis还提供了一个Watch功能，你可以对一个key进行Watch，然后再执行Transactions，在这过程中，如果这个Watched的值进行了修改，那么这个Transactions会发现并拒绝执行。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis cookbook]]></title>
    <link href="http://zhangchuan.github.com/blog/2012/01/12/143202-redis/"/>
    <updated>2012-01-12T14:32:00+08:00</updated>
    <id>http://zhangchuan.github.com/blog/2012/01/12/143202-redis</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1">1. An Introduction to Redis</a></li>
<li><a href="#2">2. Clients</a></li>
<li><a href="#3">3. Leveraging Redis</a></li>
<li><a href="#4">4. Redis Administration and Maintenance</a></li>
</ul>


<h1 id=2>CHAPTER 2 Clients</h1>


<p><strong>Using Redis from the Command Line</strong></p>

<pre><code>$ redis-cli -h
$ redis-cli -h serverip
$ redis-cli -p 6380
$ redis-cli INFO
$ cat command_list.txt | redis-cli &gt; command_output.txt
</code></pre>

<p><strong>Using Redis from Python with redis-py</strong></p>

<pre><code>$ pip install redis-py
$ easy_install redis

&gt;&gt;&gt; import redis
&gt;&gt;&gt; redis = redis.Redis(host='localhost', port=6379, db=0)
&gt;&gt;&gt; redis.smembers('circle:jdoe:soccer')
set(['users:toby', 'users:adam', 'users:apollo', 'users:mike'])
&gt;&gt;&gt; redis.sadd('circle:jdoe:soccer', 'users:fred')
True
&gt;&gt;&gt; redis.smembers('circle:jdoe:soccer')
set(['users:toby', 'users:adam', 'users:apollo', 'users:mike', 'users:fred'])  

$ pip install hiredis
$ easy_install hiredis
</code></pre>

<h1 id=3>CHAPTER 3 Leveraging Redis</h1>


<p><strong>Using Redis as a Key/Value Store</strong>
Storing application usage counters</p>

<pre><code># vists:pageid:totals
$ SET visits:1:totals 21389
$ SET visits:2:totals 1367894
$ INCR visits:635:totals    # visits:635:totals + 1
$ GET visits:635:totals
</code></pre>

<p>Storing object data in hashes</p>

<pre><code>redis&gt; hset users:jdoe name "John Doe"
(integer) 1
redis&gt; hset users:jdoe email "jdoe@test.com"
(integer) 1
redis&gt; hset users:jdoe phone "+1555313940"
(integer) 1
redis&gt; hincrby users:jdoe visits 1
(integer) 1

redis&gt; hget users:jdoe email
"jdoe@test.com"
redis&gt; hgetall users:jdoe
1) "name"
2) "John Doe"
3) "email"
4) "jdoe@test.com"
5) "phone"
6) "+1555313940"
7) "visits"
8) "1"


redis&gt; hkeys users:jdoe
1) "name"
2) "email"
3) "phone"
4) "visits"
redis&gt; hvals users:jdoe
1) "John Doe"
2) "jdoe@test.com"
3) "+1555313940"
4) "1"
</code></pre>

<p><strong>Storing user “Circles” using sets</strong></p>

<pre><code>redis&gt; sadd circle:jdoe:family users:anna
(integer) 1
redis&gt; sadd circle:jdoe:family users:richard
(integer) 1
redis&gt; sadd circle:jdoe:family users:mike
(integer) 1
redis&gt; sadd circle:jdoe:soccer users:mike
(integer) 1
redis&gt; sadd circle:jdoe:soccer users:adam
(integer) 1
redis&gt; sadd circle:jdoe:soccer users:toby
(integer) 1
redis&gt; sadd circle:jdoe:soccer users:apollo
(integer) 1

redis&gt; smembers circle:jdoe:family
1) "users:richard"
2) "users:mike"
3) "users:anna"
redis&gt; hgetall users:mike
(...)

redis&gt; sinter circle:jdoe:family circle:jdoe:soccer
1) "users:mike"
redis&gt; sunion circle:jdoe:family circle:jdoe:soccer
1) "users:anna"
2) "users:mike"
3) "users:apollo"
4) "users:adam"
5) "users:richard"
6) "users:toby"
</code></pre>

<p><strong>Quick Reference for Key Operations</strong></p>

<ul>
<li><strong>SET key value</strong></li>
<li>Sets the key to hold the given value. Existing data is overwritten (even if of a different data type).</li>
<li><strong>GET key</strong></li>
<li>Returns the content held by the key. Works only with string values.</li>
<li><strong>INCR key</strong></li>
<li>Increments the integer stored at key by 1.</li>
<li><strong>INCRBY key value</strong></li>
<li>Performs the same operation as INCR, but incrementing by value instead.</li>
<li><strong>DECR key</strong></li>
<li>Decrements the integer stored at key by 1.</li>
<li><strong>DECRBY key value</strong></li>
<li>Performs the same operation as DECR, but decrementing by value instead.</li>
<li><strong>Inspecting Your Data</strong></li>
<li>   redis> KEYS *</li>
<li>   redis> TYPE keyname</li>
</ul>


<p><strong>Quick Reference for Debugging</strong></p>

<ul>
<li><strong>KEYS pattern</strong></li>
<li>Lists all the keys in the current database that match the given pattern.</li>
<li><strong>TYPE key-name</strong></li>
<li>Tells the type of the key. Possible types are: string, list, hash, set, zset, and none.</li>
<li><strong>MONITOR</strong></li>
<li>Outputs the commands received by the Redis server in real time.</li>
<li><strong>Implementing OAuth on Top of Redis</strong></li>
<li>  redis> HMSET /consumers/key:dpf43f3p2l4k3l03 secret kd94hf93k423kf44 created_at 201103060000</li>
<li><pre><code>     redirect_url http://www.example.com/oauth_redirect name test_application
</code></pre></li>
</ul>


<p><strong>Quick Reference for Adding Values to Sets</strong></p>

<ul>
<li><strong>HSET hash-name key value</strong></li>
<li>Sets a value on a hash with the given key. As with other Redis commands, if the hash doesn’t exist, it’s created.</li>
<li><strong>HMSET hash-name key1 value1 [key2 value2 ...]</strong></li>
<li>Allows you to set several values in a hash with a single command.

<pre><code>redis&gt; HGETALL /consumers/key:dpf43f3p2l4k3l03
redis&gt; SADD /nonces/key:dpf43f3p2l4k3l03/timestamp:20110306182600 dji430splmx33448
redis&gt; EXPIRE /nonces/key:dpf43f3p2l4k3l03/timestamp:20110306182600 1800
redis&gt; HSET /request_tokens/key:dpf43f3p2l4k3l03 hh5s93j4hdidpola hdhd0244k9j7ao03
</code></pre></li>
</ul>


<p><strong>Quick Reference for Authorization Algorithm</strong></p>

<ul>
<li><strong>HGETALL hash-name</strong></li>
<li>Returns all the key/value pairs in the given hash.</li>
<li><strong>SADD set-name element</strong></li>
<li>Adds the element to the given set unless it’s already a member. The return value is 1 if the element is added and 0 if it was already a member.</li>
<li><strong>EXPIRE key seconds</strong></li>
<li>Sets an expiration timeout on a key, after which it will be deleted. This can be used on any type of key (strings, hashes, lists, sets or sorted sets) and is one of the most powerful Redis features.</li>
<li><strong>EXPIREAT key timestamp</strong></li>
<li>Performs the same operation as EXPIRE, except you can specify a UNIX timestamp (seconds since midnight, January 1, 1970) instead of the number of elapsed seconds.</li>
<li><strong>TTL key</strong></li>
<li>Tells you the remaining time to live of a key with an expiration timeout.</li>
<li><strong>PERSIST key</strong></li>
<li>Removes the expiration timeout on the given key.</li>
<li>Redirections and consent

<pre><code>redis&gt; SET /authorizations/request_token:hh5s93j4hdidpola 16
redis&gt; HGET /consumers/key:dpf43f3p2l4k3l03 redirect_url
redis&gt; HGETALL /consumers/key:dpf43f3p2l4k3l03
redis&gt; HGET /request_tokens/key:dpf43f3p2l4k3l03 hh5s93j4hdidpola
redis&gt; GET /authorizations/request_token:hh5s93j4hdidpola
redis&gt; SADD /nonces/key:dpf43f3p2l4k3l03/timestamp:20110306182700 kllo9940pd9333jh
redis&gt; EXPIRE /nonces/key:dpf43f3p2l4k3l03/timestamp:20110306182600 1800
redis&gt; HMSET /access_tokens/consumer_key:dpf43f3p2l4k3l03/access_token:nnch734d00sl2jdk
       secret pfkkdhi9sl3r4s00 user_id 16 created_at 20110306182600
redis&gt; HDEL /request_tokens/key:dpf43f3p2l4k3l03 hh5s93j4hdidpola
redis&gt; DEL /authorizations/request_token:hh5s93j4hdidpola
redis&gt; HSET /users/user_id:16/applications dpf43f3p2l4k3l03 nnch734d00sl2jdk
redis&gt; HDEL /users/user_id:16/applications dpf43f3p2l4k3l03
redis&gt; DEL /access_tokens/consumer_key:dpf43f3p2l4k3l03/access_token:nnch734d00sl2jdk
redis&gt; EXPIRE /access_tokens/consumer_key:dpf43f3p2l4k3l03/access_token:nnch734d00sl2jdk 86400
</code></pre></li>
</ul>


<p><strong>Quick Reference for Hash Operations</strong></p>

<ul>
<li><strong>HGET hash-name key</strong></li>
<li>Returns the value at key in the given hash.</li>
<li><strong>HDEL hash-name key</strong></li>
<li>Deletes a key/value pair in the given hash.</li>
</ul>


<h1 id=4>CHAPTER 4 Redis Administration and Maintenance</h1>


<p><strong>Starting a Redis Slave</strong></p>

<pre><code>redis&gt; slaveof master-ip-or-hostname masterport
redis&gt; masterauth master-password
redis&gt; SLAVEOF master-ip-or-hostname [masterport]
redis&gt; CONFIG SET masterauth password
</code></pre>

<p><strong>Handling a Dataset Larger Than Memory</strong></p>

<pre><code>vm-enabled yes
vm-swap-file
vm-max-memory
vm-pages
vm-page-size
vm-max-threads
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis.conf 配置参数]]></title>
    <link href="http://zhangchuan.github.com/blog/2012/01/11/100854-redis/"/>
    <updated>2012-01-11T10:08:00+08:00</updated>
    <id>http://zhangchuan.github.com/blog/2012/01/11/100854-redis</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
