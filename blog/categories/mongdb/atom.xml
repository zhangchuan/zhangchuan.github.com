<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MongDB | 研究中心]]></title>
  <link href="http://zhangchuan.github.com/blog/categories/mongdb/atom.xml" rel="self"/>
  <link href="http://zhangchuan.github.com/"/>
  <updated>2012-03-01T17:12:21+08:00</updated>
  <id>http://zhangchuan.github.com/</id>
  <author>
    <name><![CDATA[Cloud.Zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MongDB权威指南 6]]></title>
    <link href="http://zhangchuan.github.com/blog/2012/03/01/142455-mongodb/"/>
    <updated>2012-03-01T14:24:00+08:00</updated>
    <id>http://zhangchuan.github.com/blog/2012/03/01/142455-mongodb</id>
    <content type="html"><![CDATA[<ul>
<li>6.1 count

<pre><code># count是最简单的聚合工具, 返回集合中的文档数量
&gt; db.foo.count()
&gt; db.foo.insert({"x": 1})
&gt; db.foo.count()
&gt; db.foo.count({"x": 1})
</code></pre></li>
<li>6.2 distinct

<pre><code># distinct是用来找出给定键的所有不同值, 使用时必须指定集合和键
&gt; db.runCommand({"distinct": "people", "key": "age"})
</code></pre></li>
<li>6.3 group

<pre><code># group 先根据选定的键, 将集合依据选定键值的不同分成若干组, 然后通过聚合每一组的文档, 产生一个结果文档
{"day": "2010/10/03", "time": "10/3/2010 03:57:01 GMT-400", "price": 4.23}
{"day": "2010/10/04", "time": "10/4/2010 11:28:39 GMT-400", "price": 4.27}
{"day": "2010/10/03", "time": "10/3/2010 05:00:23 GMT-400", "price": 4.10}
{"day": "2010/10/06", "time": "10/6/2010 05:57:58 GMT-400", "price": 4.30}
{"day": "2010/10/04", "time": "10/3/2010 08:34:50 GMT-400", "price": 4.01}
# 获得近30天的收盘价
{"day": "2010/10/03", "time": "10/3/2010 05:00:23 GMT-400", "price": 4.10}
{"day": "2010/10/04", "time": "10/4/2010 11:28:39 GMT-400", "price": 4.27}
{"day": "2010/10/06", "time": "10/6/2010 05:57:58 GMT-400", "price": 4.30}
&gt; db.runCommand({"group": {
"ns": "stocks",
"key": "day",
"initial": {"time": 0},
"$reduce": function(doc, prev) {
    if (doc.time &gt; prev.time) {
        prev.price = doc.price;
        prev.time = doc.time;
    }},
"condition": {"day": {"$gt": "2010/09/30"}}
}})
# "ns": "stocks"
# 指定要进行分组的集合
# "key": "day"
# 指定文档分组依据的键. 所有"day"值相同的文档被划分到一组
# "initial": {"time": 0}
# 每一组reduce函数调用的初始时间
# "$reduce": function(doc, prev) { ... }
# 每个文档对应一次这个调用, 系统会传递两个参数: 当前文档和累加其文档. 
# "condition": {"day": {"$gt": "2010/09/30"}}
</code></pre></li>
<li>6.3.1 使用完成器

<pre><code># 博客系统, 每篇文章有多个标签, 现在要找出每天最热点的标签, 可以再一次按天分组, 为每一个标签计数
&gt; db.posts.group({
"key": {"tags": true},
"initial": {"tags": {}},
"$reduce": function(doc, prev) {
    for (i in doc.tags) {
        if (doc.tags[i] in prev.tags) {
            prev.tags[doc.tags[i]]++;
        } else {
            prev.tags[doc.tags[i]] = 1;
        }
    }
}})
# "finalize"附带一个函数, 在每组结果传递到客户端之前被调用一次. 可处理结果的残枝败叶
&gt; db.posts.group({
"key": {"tags": true},
"initial": {"tags": {}},
"$reduce": function(doc, prev) {
    for (i in doc.tags) {
        if (doc.tags[i] in prev.tags) {
            prev.tags[doc.tags[i]]++;
        } else {
            prev.tags[doc.tags[i]] = 1;
        }
    },
"finalize": function(prev) {
    var mostPopular = 0;
    for (i in prev.tags) {
        if (prev.tags[i] &gt; mostPopular) {
            prev.tag = i;
            mostPopular = prev.tags[i];
        }
    }
    delete.prev.tags
}})
</code></pre></li>
<li>6.3.2 将函数做为键使用

<pre><code>&gt; db.posts.group({"ns": "posts",
"$keyf": function(x) { return x.category.toLowerCase(); },
"initializer": ... })
</code></pre></li>
<li>6.4 MapReduce</li>
</ul>

]]></content>
  </entry>
  
</feed>
